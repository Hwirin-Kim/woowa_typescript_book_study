# 타입 활용하기

## 조건부 타입

### extends와 제네릭을 활용한 조건부 타입

#### 기본 구조

```ts
T extends U ? X : Y
```

- T가 U를 만족하면 X, 아니면 Y로 평가

#### 예시

```ts
type ApiResponse<T> = T extends "success"
  ? { ok: true; data: any }
  : { ok: false; error: string };

function handleResponse<T extends "success" | "error">(
  status: T
): ApiResponse<T> {
  return status === "success"
    ? { ok: true, data: { name: "Kim" } }
    : { ok: false, error: "Unauthorized" };
}

const success = handleResponse("success");
// ✅ { ok: true; data: any }

const fail = handleResponse("error");
// ✅ { ok: false; error: string }

fail.error; // OK
fail.data; // ❌ Property 'data' does not exist
```

### 만약 조건부 타입을 사용하지 않았을 때의 문제점

#### 조건부타입을 사용하지 않은 코드

```ts
function handleResponse(status: "success" | "error") {
  if (status === "success") {
    return { ok: true, data: { name: "Kim" } };
  } else {
    return { ok: false, error: "Unauthorized" };
  }
}

const result = handleResponse("success");
```

위 경우 TS는 result의 타입을 **_두 경우를 모두 포함한 유니온_**으로 추론한다.

```ts
// result의 타입
{
  ok: true;
  data: { name: string };
} | {
  ok: false;
  error: string;
}
```

이렇게 하면 다음과 같은 문제가 발생한다.

1. 타입이 모호하여 if문 이후에도 narrowing이 필요함

```ts
const result = handleResponse("success");

// ❌ 오류: Property 'data' does not exist on type '{ ok: false; error: string; } | { ok: true; data: any; }'
console.log(result.data);
```

2. 불필요한 타입 단언이 필요하다.

```ts
const result = handleResponse("success") as { ok: true; data: any };
console.log(result.data); // ✅ 되지만 강제 단언 필요
```

3. API 호출 래퍼나 React Query에서 불안정하다.

```ts
const { data } = useQuery({
  queryKey: ["user"],
  queryFn: () => handleResponse("success"),
});

console.log(data.data); // ❌ Property 'data' does not exist on type ...
```

### infer를 활용하여 타입 추론하기

infer는 조건부 타입 내부에서 타입을 추론(infer)해서 변수처럼 꺼내쓰는 문법!

```ts
T extends SomeType<infer U> ? U : never
```

#### Promise 내부 타입 추론 예시

```ts
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;

type A = UnwrapPromise<Promise<string>>; // ✅ string
type B = UnwrapPromise<number>; // ✅ number
```

- 왜 사용하냐?
  - async function 결과를 await 없이 타입으로 다루고 싶을 때, 혹은 React Query, axios wrapper 등에서 서버 응답 타입을 얻을때 자주 사용한다.

#### 함수 매개변수 타입 추론 예시

```ts
type ParametersOf<T> = T extends (...args: infer P) => any ? P : never;

function setUser(id: number, name: string) {}
type Params = ParametersOf<typeof setUser>;
// ✅ [number, string]
```

- 왜 사용하냐?
  - 함수의 인자 타입을 그대로 재사용할 때 편리하다.

#### 비동기 함수 반환값의 내부 데이터 타입 추론 예시

```ts
type AsyncReturn<T> = T extends (...args: any[]) => Promise<infer U>
  ? U
  : never;

const getData = async () => ({ name: "Hwirin", age: 32 });

type Data = AsyncReturn<typeof getData>;
// ✅ { name: string; age: number }
```

- 왜 사용하냐?
  - React Query, SWR, axios hooks 등에서 비동기 함수의 진짜 데이터 구조만 꺼낼때 사용한다.

## 템플릿 리터럴 타입 활용하기

```ts
type Lang = "ko" | "en" | "jp";
type Key = "title" | "desc";

type LocaleKey = `${Lang}_${Key}`;

// "ko_title" | "ko_desc" | "en_title" | "en_desc" | "jp_title" | "jp_desc"
```

#### 배민 활용 예시

```ts
type Direction =
  | "top"
  | "topLeft"
  | "topRight"
  | "bottom"
  | "bottomLeft"
  | "bottomRight";
```

위 처럼 모든 방향을 정의하면 너무 많기 때문에 아래처럼 간소화 시킬 수 있음

```ts
type Vertical = "top" | "bottom";
type Horizon = "left" | "right";

type Direction = Vertical | `${Vertical}${Capitalize<Horizon>}`;
```

## 커스텀 유틸리티 타입 활용

### PickOne

```ts
type PickOne<T> = {
  [P in keyof T]: Record<P, T[P]> &
    Partial<Record<Exclude<keyof T, P>, undefined>>;
}[keyof T];
```

#### 상세한 설명

만약 아래와 같은 파일 업로드를 위한 타입이 있다고 해보자.

```ts
interface UploadConfig {
  url: string;
  file: File;
  base64: string;
}
```

그런데 가끔 url만 넣거나, file만 넣거나 이렇게 하나만 넣고싶을때가 있다.

#### [P in keyof T]

keyof T는 "url" | "file" | "base64"처럼
객체의 모든 키 이름을 가져온다.

```ts
P = "url";
P = "file";
P = "base64";
```

#### Record<P, T[P]>

Record<key, value>는 “key 이름을 value 타입으로 갖는 객체”를 만든다.

```ts
Record<"url", string>; // => { url: string }
Record<"file", File>; // => { file: File }
Record<"base64", string>; // => { base64: string }
```

#### Exclude<keyof T, P>

이것은 지금 키를 제외한 나머지 키를 구하는것이다.  
예를 들어 지금 P가 "url"이라면

```ts
Exclude<"url" | "file" | "base64", "url">;
```

결과는 "file" | "base64"

#### Record<Exclude<keyof T, P>, undefined>

이 의미는 나머지 키들을 undefined로 둔다는 말이다.  
위에 설명했던 예제대로 "file" | "base64"를 넣으면

```ts
Record<"file" | "base64", undefined>;
// => { file: undefined; base64: undefined }
// “나머지 키들은 undefined 타입으로만 허용한다”는 뜻.
```

#### Partial<Record<...>>

있어도 되고 없어도 된다(optional) 라는 의미이다.  
지금 만든 { file: undefined; base64: undefined }를 optional로 바꾸면

```ts
{ file?: undefined; base64?: undefined }
```

#### & (교차타입)

이것은 둘 다 가진 타입을 의미한다. 그래서 결과적으로 보면

```ts
Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>;

/*
 * PickOne<UploadConfig> 결과
 * ---------------------------------
 * | P         | 결과 타입 |
 * |------------|----------------------------------------------|
 * | "url"      | { url: string; file?: undefined; base64?: undefined } |
 * | "file"     | { file: File; url?: undefined; base64?: undefined }    |
 * | "base64"   | { base64: string; url?: undefined; file?: undefined }  |
 *
 * 즉, 세 속성 중 **하나만 가질 수 있고**, 나머지는 undefined 여야 한다.
 */
```

#### 가장 쉬운 비유로 이해하기

```ts
type Menu = {
  burger: Burger;
  pizza: Pizza;
  pasta: Pasta;
};
```

위처럼 세 개의 메뉴가 있는데
`PickOne<Menu>`는

- 버거만 주문하거나 🍔
- 피자만 주문하거나 🍕
- 파스타만 주문할 수 있게 🍝 만드는 타입이다.

<br>

- 버거+피자 동시 주문 ❌
- 아무것도 주문 안하는 것도 ❌

### NonNullable을 활용한 타입가드

NonNullable을 활용하면 null이나 undefined가 섞여 있는 값들을 안전하게 필터링하거나 검사할 수 있다.

내부적으로는 다음과 같은 구조이다.

```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```

#### 사용 예시

```ts
// 이 함수는 value가 null도 아니고, undefined도 아닐때 true를 반환하는 동시에 TS에게 이 값이 NonNullable<T> 타입이다 라고 알려주는 함수이다.
function isNonNullable<T>(value: T): value is NonNullable<T> {
  return value !== null && value !== undefined;
}

const arr = [1, null, 2, undefined, 3];
const result = arr.filter(isNonNullable);

// result의 타입은 number[]
console.log(result); // [1, 2, 3]

// 즉 위 함수는 null과 undefined이면 false를 반환하고, 아닐때는 해당하는 타입으로 좁혀주게 되는것임!!
```

## 불변 객체 타입으로 활용하기

### as const 사용

```ts
const colors = {
  red: "#F45452",
  green: "#0C952A",
  blue: "#1A7CFF",
};

const getColorHex = (key: string) => colors[key];
```

위 처럼 string으로 설정하면 getColorHex의 반환값이 any가 된다. colors에 어떤 값이 추가될 수도 있기 때문에 단언할 수 없는 것이다.

그래서 `as const`를 붙여서 불변 객체로 선언하고 `keyof`연산자를 활용하여 colors객체에 있는 key값만 받도록 설정할 수 있다.

```ts
const colors = {
  red: "#F45452",
  green: "#0C952A",
  blue: "#1A7CFF",
} as const;

const getColorHex = (key: string) => colors[key];
```

### keyof와 typeof로 따라하기

```ts
const colors = {
  red: "#F45452",
  green: "#0C952A",
  blue: "#1A7CFF",
};

type ColorsType = typeof colors; // 객체의 타입을 추출
type ColorKey = keyof ColorsType; // 객체의 키 추출

const getColorHex = (key: ColorKey) => colors[key];

// ColorsType은 아래처럼 해석 된다.
type ColorsType = {
  red: string;
  green: string;
  blue: string;
};

// ColorKey는 아래처럼 해석 된다.
type ColorKey = "red" | "green" | "blue";
```

## Record 원시 타입 키 개선하기

Record<K,T>는 특정 키(K)집합에 대한 밸류값의 타입을 T로 일정하게 지정하는 문법이다.

그런데 여기서 K를 원시타입으로 지정하면 발생하는 문제가 있다.

```ts
type Category = string;
interface Food {
  name: string;
}

const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};
```

위 예시에서 Category는 string이기 때문에 다음과 같이 사용하여도 오류가 발생하지 않는다.

```ts
const 양식배열 = foodByCategory["양식"]; //이 값을 food[]로 추론하게 됨
양식배열.map((food) => console.log(food.name)); //이렇게 해도 오류가 발생하지 않음
```

그러나 당연히 양식 키를 가진 값은 없으므로 런타임에서 undefined가 되어 map을 돌리는 부분에서 오류를 반환하게 된다.

이때 optional chaining을 통해 런타임 에러를 방지할 수 있다.

```ts
양식배열?.map((food) => console.log(food.name));
```

하지만 이는 타입스크립트를 사용하는 의미가 전혀 없다.  
어떤 값이 undefined인지 매번 판단해야하고, 예상치 못한 오류로 이어질 수 있기 때문이다.

그래서 다음과 같은 방법으로 안전하게 사용하기를 권장한다.

### 유닛 타입으로 변경하기

```ts
type Category = "한식" | "일식";
interface Food {
  name: string;
}

const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};
```

이렇게 사용하면 양식을 키로 사용할 수 없으므로 간단히 해결 가능하다.

하지만 키가 정해지지 않은 상황에서는 사용할 수 없다.

### Partial을 활용한 정확한 타입 표현

키 값이 정해지지 않은 상황에서는 Partial을 사용하여 해당 값이 undefined일 수 있다는 상태임을 표현시켜줘야 한다.

```ts
type PartialRecord<K extends string, T> = Partial<Record<K, T>>;
type Category = string;

interface Food {
  name: string;
}

const foodByCategory: PartialRecord<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }, { name: "뚝배기 불고기" }],
  일식: [{ name: "초밥" }, { name: "텐동" }],
};

const 양식배열 = foodByCategory["양식"]; // Food[]또는 undefined 타입으로 추론한다.
양식배열.map(); // undefined가 포함되기 때문에 바로 오류가 발생한다. 따라서 개발자들은 이것을 보고 옵셔널 체이닝을 넣어줘야한다고 판단할 수 있다.

양식배열?.map(); // 이제 개발자는 실수없이 undefined가 나올걸 예상하고 옵셔널 체이닝을 추가한다.
```
